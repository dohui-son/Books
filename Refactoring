# 서문

---

- When 언제
    - 언제 리팩터링을 시장 하는 것이 적절한가
    - 리팩터링이 기준 이상으로 필요한 코드들은 일정 패턴이 존재
    - 리팩터링 종료의 정확한 기준 미정
- How 어떻게
    - 어떤 리팩터링 기법을 적용할 것인가
    - 다음과 같은 코드 악취(리팩터링을 필요로 하는 패턴들) 리스트를 살펴보고 6-12장의 리팩터링 기법을 적용하자
- Conclusion
    - 리팩터링이 필요한 패턴을 분석한 후 리팩터링 필요한 시점을 판단
    - 리팩터링이 필요한 패턴을 통해 코드 악취 원인 진단 가능
    

# 3.1 기이한 이름 Mysterious Name

---

**부적절한 네이밍은 리팩터링의 대상이 된다.**

- 좋은 코드를 위한 조건 “네이밍”
    - 좋은 코드는 명료하고 가독성이 뛰어나야함
    - 네이밍을 통해 가능한 것 (1) 네이밍 == 역할 및 사용법 명시 (e.g. 함수, 모듈, 변수, 클래스)
    - 네이밍을 통해 가능한 것 (2) 네이밍으로 컨텍스트 파악 어려움 해소
- 리팩터링 기법
    - 함수 선언 변경
    - 변수 이름 변경
    - 필드 이름 변경
- 네이밍 VS 아키텍쳐
    - 네이밍이 심각하게 어려운 경우, 설계에 문제가 숨어있을 수 있다.
    - 네이밍을 통해 가능한 것 (1) 근본적인 코드 문제 발견 가능
    - 네이밍을 통해 가능한 것 (2) 로직 개선

# 3.2 중복 코드 Duplicated Code

---

**코드 중복을 통합할 때 차이점 분석이 필요하다.**

- 중복되는 코드를 리팩터링 ⇒ 소프트웨어 개선
- 리팩터링 기법
    - case. 한 클래스에 딸린 두 메서드가 똑같은 표현식 사용
    - 해결 방안 (1) 코드 동일한 경우 - 함수 추출하기 → 양쪽 모두 추출된 메서드 호출 수정
    - 해결 방안 (2) 코드 유사한 경우 - 문장 슬라이드하기 → 유사한 부분 모아 함수 추출 적용 방안 탐구
    - 해결 방안 (3) 동일 부모에서 파생된 서브 클래스 코드 중복 경우 - 메서드 올리기 (부모로 옮기기)

# 3.3 긴 함수 Long Function

---

**짧은 함수는 간접호출(indirection) 효과, 즉 코드 이해/공유/활용의 가능성을 높인다.**

- 짧은 함수
    - 과거와 달리 함수 호출비용 문제 X
    - 가독성 향상 - 네이밍이 적절한 짧은 함수는 내부를 살펴볼 필요가 없고 전체 코드 가독성 증진에 기여
- 함수 작성 Tip
    - 주석으로 남기려던 설명을 코드에 담아 함수를 구성하라!
    - 함수 이름은 동작 방식이 아닌 의도(목적)가 드러나게 지어라!
    - 원래 코드보다 길어지더라도 함수 하라!
    - 코드가 “무엇을 하는지”(목적, 의도) 잘 설명하지 못할수록 함수화 하라!
- 리팩터링 기법
    - 함수 추출하기
    - case. 추출된 함수에서 임시변수 매개변수가 너무 많아서 함수가 난해한 경우
        - 임시 변수를 질의 함수로 바꾸기 기법 - 임시 변수 수 감소
        - 매개변수 객체 만들기 기법 - 매개변수 수 감소
        - 객체 통째로 넘기기 기법 - 매개변수 수 감소
        - 함수를 명령으로 바꾸기 기법 - 임시 변수와 매개변수가 과하게 많은 경우
- 함수화 Tip
    - 주석 참고하기
        - 주석은 코드만으로 이해가 어려운 경우 사용
        - 주석 설명 대상 코드를 함수화, 네이밍에도 주석 참고
    - 조건문 확인하기
        - 조건문 분해하기 기법
        - 거대한 switch문은 case문마다 함수 추출하기 기법 적용 - 각 case문 본문을 함수 호출문 하나로 대체
        - 동일 조건 기준으로 나뉘는 switch문 반복 - 조건부 로직을 다형성으로 바꾸기 기법 적용
    - 반복문 확인하기
        - 반복문 추출해서 함수화
        - 해당 함수 네이밍 어려울시 두가지 이상 역할 공존 확인 → 반복문 쪼개기 기법 적용

# 3.4 긴 매개변수 목록

---

**전역 데이터 감소를 위해 상대적으로 길어진 매개변수들은 이해도를 감소시키는 부작용을 낳는다.**

- 긴 매개변수 해결 방안
    - 매개변수를 질의 함수로 대체 기법 -  다른 매개변수에서 값을 얻어올 수 있는 매개변수
    - 객체 통째로 넘기기 기법 - 사용 중인 데이터 구조에서 값을 뽑아 별개 매개변수로 전달하는 코드
    - 매개변수 객체 만들기 기법 - 항상 함께 전달되는 매개변수들
    - 플래그 인수 제거하기 기법 - 함수 동작 방식을 정하는 열할의 매개변수들
    - 여러 함수를 클래스로 묶기
        - 여러 개의 함수가 특정 매개변수들의 값을 공통으로 사용할 때
        - 공통 값들을 클래스의 필드로 정의
        - 함수형 프로그래밍의 경우 부분 적용함수partially applied func를 생성

# 3.5 전역 데이터

---

**전역 데이터 남발은 코드베이스 어디서나 접근 가능하고 누가 어디서 값 변경 확인 불가능으로 코드 악취가 심하다.**

- 전역 데이터가 많으면 디버깅 어려움 유발
- 변수 캡슐화하기 기법
    - 다른 코드에서 오염 가능성 있는 데이터에 적용
    - 함수로 변수를 감싸는 것만으로도 값변경 시점 판단 가능
    - 접근 통제 가능
    - 접근자 함수들을 클래스나 모듈에 넣고 그 안에서만 사용 → 접근 범위 최소화

# 3.6 가변 데이터

---

**데이터 변경은 버그의 원인이다.**

- 무분별한 데이터 수정 위험성 낮추는 Tip
    - 변수 캡슐화하기 기법 - 특정 함수로만 값 수정 가능하게 만들기
    - 변수 쪼개기 기법 - 한개 변수에 여러 값을 저장하기 위해 값을 여러번 갱신하는 경우
    - 문장 슬라이드하기+함수 추출하기 기법 - 변수값 갱신 로직을 분리
    - 질의 함수와 변경 함수 분리하기 기법 - API 개발시 꼭 필요한 경우가 아니라면 부작용있는 코드를 호출할 수 없도록
    - 세터 제거하기 기법 - 제거 가능한 세터함수를 줄여서 변수 유효범위 축소
    - 파생 변수를 질의함수로 바꾸기 기법 - 값을 다른 곳에서 설정할 수 있는 가변 데이터 문제 해결
    - 여러 함수를 클래스로 묶기 기법 / 여러 함수를 변환 함수로 묶기 기법 - 변수 유효 범위 제한
    - 참조를 값으로 바꾸기 기법 - 구조체처럼 내부 필드에 데이터를 담고 있는 변수의 경우, 내부 필드를 직접 수정하지 않고 구조체를 통째로 교체
    

# 3.7 뒤엉킨 변경

---

**단일 책임 원칙 SRP가 지켜지지 않으면 뒤엉킨 변경을 유발한다.**

- e.g. 지원해줘야하는 데이터베이스가 추가될 때마다 함수 세개를 꼭 바꿔줘야하는 경우
- e.g. 금융 상품 추가될 때마다 다른 함수 네개를 바꿔줘야하는 모듈
- 뒤엉킨 변경 해결 Tip
    - 소프트웨어가 계속 변경됨에 따라 기준이 바뀌기에 나중에 단일 책임 원칙이 안 지켜질 수도 있다.
    - 단계 쪼개기 기법 - 순차적 로직의 경우
    - 함수 옮기기 기법 - 맥락에 따른 모듈을 만들고 관련함수 모아보기. 처리과정이 맥락별로 구분되는 경우.
    - 함수 추출하기 기법/클래스 추출하기 기법 - 맥락 별 분리 방법에 이용 가능.

# 3.8 산탄총 수술

---

**코드 변경 때마다 수정해야하는 클래스가 많으면 리팩터링이 필요할까 의심해봐야한다.**

- 뒤엉킨 변경과 산탄총 수술 비교
    
    ![IMG_0F9C76DBDF2C-1.jpeg](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b5e533e-decc-4a7b-bf17-aaf9221285c0/87920bb4-f686-462e-9fbd-f47865c7d381/IMG_0F9C76DBDF2C-1.jpeg)
    
- 문제 상황 - 기능 추가시 수정 대상이 코드 전반에 산재
- 해결 방안
    - 함수 옮기기 기법 + 필드 옮기기 기법 - 변경 대상을 한 모듈에 묶어주기
    - 여러 함수를 클래스로 묶기 기법 - 비슷한 데이터 다루는 함수가 많은 경우
    - 여러 함수를 변환 함수로 묶기 기법 - 데이터 구조 변환 혹은 보강enrich 함수들 대상
    - 단계 쪼개기 기법 - 묶여진 함수들의 출력 결과를 묶어서 다음 단계 로직으로 전달 가능할때
    - 함수 인라인 기법 - 차후에 함수가 비대해지면 그 시점에 리팩터링으로 분리
    - 클래스 인라인 기법 - 차후에 클래스가 비대해지면 그 시점에 리팩터링으로 분리

# 3.9 기능 편애

---

**기능 편애 원인은 보통 특정 함수가 자기가 속한 모듈의 함수나 데이터보다 다른 모듈의 함수나 데이터와 상호작용 할일이 많을때 발생한다.**

- e.g. 외부 객체의 게터 메서드 여섯개 이상을 호출하도록 작성된 함수
- 해결 방안
    - 함수 옮기기 기법 - 데이터 가까이로 옮겨주기
    - 함수 추출하기 기법 → 함수 옮기기 기법 - 함수의 일부에서만 기능 편애하는 경우 대상
    - “가장 많은 데이터를 포함한 모듈로 옮기기” - 함수가 사용하는 모듈이 다양한 경우
    - 위의 모든 경우가 다 포함되는 복잡한 경우 대응 방안
        - 전략 패턴
        - 방문자 패턴
        - 자기 위임
        - ⇒ “함께 변경할 대상을 한데 모으기”

# 3.10 데이터 뭉치

---

**데이터들은 함께 사용되는 상황이 많이 발생한다. 그리고 이런 경우는 일반적이다.**

- 해결 방안
    - 클래스 추출하기 기법 - 하나 객체로 묶기
    - 매개변수 객체 만들기 / 객체 똥째로 넘기기 - 매개 변수 수 감소

# 3.11 기본형 집착

---

**특징있는 대상을 기본형으로 표현하여 유관 기능을 놓치는 경우가 많다.** 

- e.g. 전화번호를 단순 문자열로 표현
    - 일관된 형식으로 출력해주는 필수적인 기능 간과
- 해결 방안
    - 기본형을 객체로 바꾸기 기법
    - 타입 코드를 서브클래스로 바꾸기 → 조건부 로직을 다형성으로 바꾸기 - 기본형으로 표현된 코드가 조건부 동작을 제어하는 타입 코드인 경우

# 3.12 반복되는 switch문

---

**중복된 switch문은 조건절 추가때마다 다른 switch문을 모두 수정해야한다면 문제가 된다.**

- 조건부 로직을 다형성으로 바꾸기로 해결 가능

# 3.13 반복문

---

**일급 함수를 지원하는 언너는 반복문을 파이프라인으로 바꾸기 기법을 적용하자.**

- e.g. `filter`, `map` 이용시 원소 처리 방식을 쉽게 이해 가능

# 3.14 성의 없는 요소

---

**미래 상황을 가정하여 과하게 사용된 프로그램 요소(메서드 추가를 계획한 클래스)가 필요없으면 제거한다. ~~개발자적 뇌피셜 그만~~**

- 해결 방안
    - 함수 인라인하기 기법
    - 클래스 인라인하기 기법
    - 계층 합치기 기법 - 상속 사용한 상황

# 3.15 추측성 일반화

---

‘**나중에 필요할거야’는 레거시 코드를 늘린다.**

- 해결 방안
    - 함수 인라인하기 기법
    - 클래스 인라인하기 기법
    - 계층 합치기 기법 - 상속 사용한 상황
    - 죽은 코드 제거하기 기법

# 3.16 임시 필드

---

**특정 상황에서만 값이 설정되는 필드를 가진 클래스는 제 3자가 보기에 이해하기 어렵다.**

- 해결 방안
    - 클래스 추출하기 기법
    - 함수 옮기기 기법 - 추출된 클래스에 해당 필드와 관련된 코드를 새 클래스에 몰아 넣기
    - 특이 케이스 추가하기 기법 - 특정 필드들이 유효하지 않을 때를 위한 대안 클래스 추가

# 3.17 메시지 체인

---

**클라이언트가 한 객체를 통해 다른 객체를 얻은 후 방금 얻은 객체에 또 다른 객체 요청하는, 연쇄적인 코드는 내비게이션 중간 단계 수정 시 클라이언트 코드도 수정해야하는 문제가 있다. 메서드 체인이 무조건 나쁜 것은 아니다.**

- 해결 방안
    - 위임 숨기기 기법
        - 메시지 체인 연결점에 적용하면 효율적
        - 체인 구성하는 모든 객체에 적용하면 중간 객체들 모두 중개자가 되는 문제 발생
    - 함수 추출하기 기법 → 함수 옮기기 기법
        - 체인을 숨길 수 있는지 확인 필요
        - 체인 구성하는 객체 중 일부를 사용하는 클라이언트가 다수면 이를 처리하는 메서드 추가
    - e.g.
        
        ![스크린샷 2023-11-29 오후 9.44.15.png](https://prod-files-secure.s3.us-west-2.amazonaws.com/6b5e533e-decc-4a7b-bf17-aaf9221285c0/bdeaaf3d-3a74-47a6-b45e-9f7e6ba2e4be/%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA_2023-11-29_%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE_9.44.15.png)
        
    

# 3.18 중개자

---

**클래스가 제공하는 메서드 중 절반이 다른 클래스에 구현을 위임하고 있다면 문제가 된다.**

- 해결 방안
    - 중개자 제거하기 기법 - 실제로 일을 하는 객체와 직접 소통하기

# 3.19 내부자 거래

---

**데이터 주고받는 모듈이 많은 어쩔 수 없는 특정 상황에 대응하는 방법을 소개한다.**

- 해결 방법
    - 함수 옮기기 기법 + 필드 옮기기 기법
    - 제 3의 모듈 생성 + 위임 숨기기 기법 - 다른 모듈이 중간자 역할을 하도록
    - 서브 클래스를 위임으로 바꾸기 기법 - 상속 구조에서 이런 상황을 해결해야하는 경우
    - 슈퍼 클래스를 위임으로 바꾸기 기법 - 상속 구조에서 이런 상황을 해결해야하는 경우

# 3.20 거대한 클래스

---

**클래스가 너무 많은 일을 할때는 리팩터링이 필요하다.**

- 해결 방법
    - 클래스 추출하기 기법
        - 같은 컴포넌트에 모아두는 것이 합당한 필드만 따로 묶기
        - e.g. `depositAmount`, `depositCurrency`
    - 슈퍼클래스 추출하기 기법 - 분리할 컴포넌트를 상속관계인 경우
    - 타입 코드를 서브 클래스로 바꾸기 기법 - 분리할 컴포넌트를 상속관계인 경우

# 3.21 서로 다른 인터페이스의 대안 클래스들

---

**인터페이스가 같은 경우 기존 클래스를 다른 클래스로 교체할 수도 있다.**

- 다른 클래스로 교체 Tip
    - 함수 선언 바꾸기 기법 - 메서드 시그니처를 먼저 일치 시키는 작업 필요
    - 함수 옮기기 기법 - 인터페이스가 동일해질 때까지 클래스에 추가해주는 작업 필요
    - 슈퍼클래스 추출하기 기법 - 대안 클래스 사이의 중복 코드 제거 필요

# 3.22 데이터 클래스

---

**데이터 클래스(게터/세터 메서드로만 구성된 클래스)는 리팩터링 필요성을 확인해봐야한다.**

- 문제 상황 - 이 경우 데이터 저장 용도로만 쓰여서 다른 클래스가 너무 깊이까지 관여
- 해결 방안
    - 레코드 캡슐화하기 기법
    - 세터 제거하기 기법 - 변경하면 안 되는 필드의 경우
    - 함수 옮기기 기법 - 데이터 클래스의 게터 세터를 사용하는 메서드를 찾아서 데이터 클래스로 옮기기
    - 함수 추출하기 기법 - 메서드를 데이터 클래스로 옮기기 힘든 경우 일부만 별도 메서드로 분리
    - 클라이언트 코드를 데이터 클래스로 옮기기
    - 불변 필드는 캡슐화 필요성이 없음으로 게터 삭제 후 공개

# 3.23 상속 포기

---

**일부만 상속을 원하는 경우라고 무조건 계층구조 설계 오류인 것은 아니다. 하지만 서브 클래스가 부모 동작을 필요로 하지만 인터페이스는 따르고 싶지 않은 경우는 리팩터링을 의심해봐야한다.**

- 상속 메커니즘 벗어나기 Tip
    - 서브 클래스를 위임으로 바꾸기 기법
    - 슈퍼클래스를 위임으로 바꾸기 기법

# 3.24 주석

---

주석을 남겨야겠다는 생각이 들면, **가장 먼저 주석이 필요 없는 코드로 리팩터링해본다. 주석이 필요한 경우에는 매우 유용할 수 있다.**

- 주석 다이어트 Tip
    - 함수 추출하기 기법 → 함수 선언 바꾸기
    - 이서션 추가하기 기법 - 시스템 동작을 위한 선행조건 명시가 필요한 경우
- 주석이 약이 될때
    - 뭘 할지 모를 때
    - 확실하지 않은 부분
    - 코드를 이렇게 작성한 이유
    

# Dictionary

---

- 질의함수 - 연산을 통해 값을 계산하여 반환하는 함수
